<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Decision Tree Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Decision Tree Challenge</h1>
<p class="subtitle lead">Feature Importance and Categorical Variable Encoding</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="decision-tree-challenge---feature-importance-and-variable-encoding" class="level1">
<h1>üå≥ Decision Tree Challenge - Feature Importance and Variable Encoding</h1>
<section id="the-ames-housing-dataset" class="level2">
<h2 class="anchored" data-anchor-id="the-ames-housing-dataset">The Ames Housing Dataset üè†</h2>
<p>We are analyzing the Ames Housing dataset which contains detailed information about residential properties sold in Ames, Iowa from 2006 to 2010. This dataset is perfect for our analysis because it contains a categorical variable (like zip code) and numerical variables (like square footage, year built, number of bedrooms).</p>
</section>
<section id="the-problem-zipcode-as-numerical-vs-categorical" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-zipcode-as-numerical-vs-categorical">The Problem: ZipCode as Numerical vs Categorical</h2>
<p><strong>Key Question:</strong> What happens when we treat zipCode as a numerical variable in a decision tree? How does this affect feature importance interpretation?</p>
<p><strong>The Issue:</strong> Zip codes (50010, 50011, 50012, 50013) are categorical variables representing discrete geographic areas, i.e.&nbsp;neighborhoods. When treated as numerical, the tree might split on ‚ÄúzipCode &gt; 50012.5‚Äù - which has no meaningful interpretation for house prices. Zip codes are non-ordinal categorical variables meaning they have no inherent order that aids house price prediction (i.e.&nbsp;zip code 99999 is not the priceiest zip code).</p>
</section>
<section id="data-loading-and-model-building" class="level2">
<h2 class="anchored" data-anchor-id="data-loading-and-model-building">Data Loading and Model Building</h2>
<div id="load-and-model-python" class="cell" data-execution_count="1">
<div class="cell-output cell-output-stdout">
<pre><code>Model built with 8 terminal nodes</code></pre>
</div>
</div>
</section>
<section id="tree-visualization" class="level2">
<h2 class="anchored" data-anchor-id="tree-visualization">Tree Visualization</h2>
<div id="cell-visualize-tree-python" class="cell" data-fig-height="6" data-fig-width="10" data-execution_count="2">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/visualize-tree-python-output-1.png" id="visualize-tree-python" width="942" height="566" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>:::</p>
</section>
<section id="feature-importance-analysis" class="level2">
<h2 class="anchored" data-anchor-id="feature-importance-analysis">Feature Importance Analysis</h2>
<div id="cell-importance-plot-python" class="cell" data-fig-height="5" data-fig-width="8" data-execution_count="4">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/importance-plot-python-output-1.png" id="importance-plot-python" width="758" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="proper-categorical-encoding-the-solution" class="level2">
<h2 class="anchored" data-anchor-id="proper-categorical-encoding-the-solution">Proper Categorical Encoding: The Solution</h2>
<p><strong>Python Approach:</strong> One-hot encode zipCode (create dummy variables for each zip code)</p>
<section id="categorical-encoding-analysis" class="level3">
<h3 class="anchored" data-anchor-id="categorical-encoding-analysis">Categorical Encoding Analysis</h3>
</section>
<section id="tree-visualization-categorical-zipcode" class="level3">
<h3 class="anchored" data-anchor-id="tree-visualization-categorical-zipcode">Tree Visualization: Categorical zipCode</h3>
<div id="cell-visualize-tree-cat-python" class="cell" data-fig-height="6" data-fig-width="10" data-execution_count="6">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/visualize-tree-cat-python-output-1.png" id="visualize-tree-cat-python" width="938" height="566" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="feature-importance-categorical-zipcode" class="level3">
<h3 class="anchored" data-anchor-id="feature-importance-categorical-zipcode">Feature Importance: Categorical zipCode</h3>
<div id="cell-importance-plot-cat-python" class="cell" data-fig-height="5" data-fig-width="8" data-execution_count="7">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/importance-plot-cat-python-output-1.png" id="importance-plot-cat-python" width="757" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="discussion-questions-and-answers-for-challenge" class="level2">
<h2 class="anchored" data-anchor-id="discussion-questions-and-answers-for-challenge">Discussion Questions and Answers for Challenge</h2>
<section id="answer-to-question-1-numerical-vs-categorical-encoding" class="level3">
<h3 class="anchored" data-anchor-id="answer-to-question-1-numerical-vs-categorical-encoding">Answer to Question 1: Numerical vs Categorical Encoding</h3>
<p><strong>How should zip code be modeled?</strong></p>
<ul>
<li>Zip code should be modeled as a categorical variable, not numerical</li>
<li>Although it looks like a number, zip code represents neighborhood identity‚Äînot a measurable quantity</li>
<li>The difference between 50011 and 50012 has no economic meaning for house prices</li>
</ul>
<p><strong>Is zip code ordinal or non-ordinal?</strong></p>
<ul>
<li>Zip code is non-ordinal‚Äîthere‚Äôs no meaningful order among zip codes that helps predict house prices</li>
<li>Unlike age, income, or square footage where higher values naturally mean more, zip codes don‚Äôt work that way</li>
<li>When we treat zip code as a number, the model assumes false ordering (like zip code 50013 is ‚Äúgreater than‚Äù 50012), which makes no sense for neighborhoods</li>
</ul>
<p><strong>Why categorical variables need special treatment</strong></p>
<ul>
<li>When treated numerically, decision trees create meaningless splits like ‚ÄúIs zip code less than 50011.5?‚Äù</li>
<li>These comparisons don‚Äôt make sense for neighborhoods</li>
<li>Feature importance gets distorted because it‚Äôs based on artificial numeric thresholds rather than real location differences</li>
<li>With categorical encoding (one-hot), the tree asks meaningful questions like ‚ÄúIs this property in zip code 50012?‚Äù</li>
<li>This produces valid splits and trustworthy feature importance scores</li>
</ul>
<p><strong>What my outputs showed</strong></p>
<ul>
<li>When I treated zip code as numeric, it had almost zero importance (around 0.00%)</li>
<li>This isn‚Äôt telling us neighborhoods don‚Äôt matter‚Äîit‚Äôs telling us the encoding was wrong</li>
<li>When I switched to categorical encoding, each zip code dummy variable had small but real importance</li>
<li>This showed me that structural features (like square footage and garage size) dominate price prediction, but at least now the model evaluates neighborhoods correctly</li>
</ul>
<hr>
</section>
<section id="answer-to-question-2-r-vs-python-implementation-differences" class="level3">
<h3 class="anchored" data-anchor-id="answer-to-question-2-r-vs-python-implementation-differences">Answer to Question 2: R vs Python Implementation Differences</h3>
<p><strong>Why the output tree and feature importance differ between R and Python</strong></p>
<ul>
<li>R and Python handle categorical variables very differently</li>
<li>R‚Äôs <code>rpart</code> package natively understands categorical variables (what R calls ‚Äúfactors‚Äù)</li>
<li>When you pass a categorical variable to <code>rpart</code> in R, the algorithm can directly work with the categories</li>
<li>Python‚Äôs scikit-learn doesn‚Äôt support categorical variables at all‚Äîeverything has to be a number</li>
<li>This forced me to use one-hot encoding as a workaround</li>
</ul>
<p><strong>What R offers that Python does not</strong></p>
<ul>
<li>R can learn grouped splits‚Äîfor example, putting zip codes {50010, 50012, 50014} in one group versus {50011, 50013, 50015} in another, all in a single node</li>
<li>Python, with one-hot encoding, can only split on individual dummy variables, one at a time</li>
<li>Zip code stays as one conceptual feature in R, but gets split across 25+ binary features in Python</li>
<li>R keeps ‚Äúneighborhood‚Äù as a single meaningful feature with cleaner feature importance</li>
</ul>
<p><strong>Limitations of Python (supported by official documentation)</strong></p>
<p>From the <a href="https://scikit-learn.org/stable/modules/tree.html">scikit-learn Decision Tree documentation</a>:</p>
<blockquote class="blockquote">
<p>‚ÄúThe implementation of trees does not currently support categorical variables: they need to be encoded as integers or floats. As a result, categorical features are split based on their integer encoding, which often results in suboptimal splits.‚Äù</p>
</blockquote>
<p>This directly explains what I observed‚Äîsklearn treats everything as numerical, which leads to suboptimal splits for categorical data.</p>
<p><strong>Which language models zip code better?</strong></p>
<ul>
<li>I think R does a better job modeling zip code as a categorical variable</li>
<li>R treats it as a true categorical, allows multi-level splits, and keeps ‚Äúneighborhood‚Äù as a single meaningful feature</li>
<li>The feature importance comes out cleaner and easier to interpret</li>
<li>Python works, but it‚Äôs more of a workaround‚ÄîI had to create 25+ binary features through one-hot encoding</li>
<li>This splits zip code importance across all those dummy variables, making the tree wider, harder to interpret, and diluting the zip code importance score</li>
</ul>
<hr>
</section>
<section id="answer-to-question-3-better-categorical-handling-in-python" class="level3">
<h3 class="anchored" data-anchor-id="answer-to-question-3-better-categorical-handling-in-python">Answer to Question 3: Better Categorical Handling in Python</h3>
<p>Even though sklearn‚Äôs basic <code>DecisionTreeRegressor</code> doesn‚Äôt support categorical variables, there are better options in Python that handle categories more intelligently than simple one-hot encoding.</p>
<p><strong>Option 1: HistGradientBoosting (scikit-learn)</strong></p>
<ul>
<li>Tree-based model from scikit-learn (not a single tree, but an ensemble) that can understand categorical features</li>
<li>From the <a href="https://scikit-learn.org/stable/modules/ensemble.html#categorical-support">scikit-learn documentation</a>: ‚ÄúHistGradientBoostingClassifier and HistGradientBoostingRegressor have native support for categorical features: they can consider splits on non-ordered, categorical data.‚Äù</li>
<li>If you‚Äôre willing to use a boosted tree model instead of a single tree, this is the official scikit-learn way to get proper categorical handling</li>
</ul>
<p><strong>Option 2: CatBoost</strong></p>
<ul>
<li>Python library built specifically for handling categorical variables</li>
<li>The <a href="https://catboost.ai/docs/concepts/algorithm-main-stages_cat-to-numberic.html">CatBoost documentation</a> explicitly warns: ‚ÄúDo not use one-hot encoding during preprocessing. This affects both the training speed and the resulting quality.‚Äù</li>
<li>You just pass zip codes directly as strings or integers, and it transforms them internally without creating all those dummy columns</li>
</ul>
<p><strong>Option 3: LightGBM</strong></p>
<ul>
<li>Another library that handles categoricals natively</li>
<li>From the <a href="https://lightgbm.readthedocs.io/en/latest/Features.html">LightGBM documentation</a>: ‚ÄúIt is common to represent categorical features with one-hot encoding, but this approach is suboptimal for tree learners‚Ä¶ Instead of one-hot encoding, the optimal solution is to split on a categorical feature by partitioning its categories into 2 subsets.‚Äù</li>
<li>You mark columns as categorical, and LightGBM finds optimal splits internally</li>
</ul>
<p><strong>Summary</strong></p>
<ul>
<li>If you want proper categorical handling in Python without one-hot encoding, step beyond plain <code>DecisionTreeRegressor</code></li>
<li>Use one of these modern tree-based methods: <code>HistGradientBoosting</code>, <code>CatBoost</code>, or <code>LightGBM</code></li>
<li>They all learn smarter splits directly on categorical values instead of treating them like numbers</li>
</ul>
<hr>
<div id="state-of-the-art-python" class="cell" data-execution_count="8">
<div class="cell-output cell-output-stdout">
<pre><code>
=== Summary of R^2 scores ===
HistGradientBoostingRegressor: 0.827
CatBoostRegressor           : 0.845
LightGBM LGBMRegressor      : 0.826</code></pre>
</div>
</div>
</section>
</section>
<section id="submission-checklist" class="level2">
<h2 class="anchored" data-anchor-id="submission-checklist">Submission Checklist ‚úÖ</h2>
<p><strong>Minimum Requirements (Required for Any Points):</strong></p>
<ul class="task-list">
<li><label><input type="checkbox">Forked starter repository from <a href="https://github.com/flyaflya/decTreeChallenge.git">https://github.com/flyaflya/decTreeChallenge.git</a></label></li>
<li><label><input type="checkbox">Cloned repository locally using Cursor (or VS Code)</label></li>
<li><label><input type="checkbox">Added thoughtful narrative answers to both discussion questions</label></li>
<li><label><input type="checkbox">Document rendered to HTML successfully</label></li>
<li><label><input type="checkbox">HTML files uploaded to your forked repository</label></li>
<li><label><input type="checkbox">GitHub Pages enabled and working</label></li>
<li><label><input type="checkbox">Site accessible at <code>https://[your-username].github.io/decTreeChallenge/</code></label></li>
</ul>
<p><strong>75% Grade Requirements:</strong></p>
<ul class="task-list">
<li><label><input type="checkbox">Clear, well-reasoned answer to question 1 about numerical vs categorical encoding</label></li>
</ul>
<p><strong>85% Grade Requirements:</strong></p>
<ul class="task-list">
<li><label><input type="checkbox">Thorough analysis of question 2 with investigation of official documentation</label></li>
</ul>
<p><strong>95% Grade Requirements:</strong></p>
<ul class="task-list">
<li><label><input type="checkbox">Professional presentation style appropriate for business audience.</label></li>
<li><label><input type="checkbox">Specific quote from official documentation of <code>sklearn.tree.DecisionTreeRegressor</code> supporting your analysis</label></li>
</ul>
<p><strong>100% Grade Requirements:</strong></p>
<ul class="task-list">
<li><label><input type="checkbox">Note on the current state of the art in decision tree implementation for categorical variables in Python.</label></li>
</ul>
<p><strong>Report Quality (Critical for Higher Grades):</strong></p>
<ul class="task-list">
<li><label><input type="checkbox">Clear, engaging narrative that tells a story</label></li>
<li><label><input type="checkbox">Focus on the most interesting findings about decision tree feature importance</label></li>
<li><label><input type="checkbox">Professional writing style (no AI-generated fluff)</label></li>
<li><label><input type="checkbox">Concise analysis that gets to the point</label></li>
<li><label><input type="checkbox">Practical insights that would help a real data scientist</label></li>
<li><label><input type="checkbox">Documentation-based analysis for technical questions</label></li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>